// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: identity.proto

package api

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	_ "github.com/mwitkow/go-proto-validators"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Login описывает информацию для регистрации нового пользователя.
// Используемый в логине домен автоматически возвращается в информации об
// авторизованном пользователе, хоть его физической привязки к домену нет.
type Login struct {
	// домен
	Domain string `protobuf:"bytes,1,opt,name=domain,proto3" json:"domain,omitempty"`
	// email-адрес пользователя (используется в качестве логина)
	Email string `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
	// пароль пользователя
	Password string `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	// необязательная дополнительная информация об источнике регистрации
	RegInfo `protobuf:"bytes,10,opt,name=reg_info,json=regInfo,proto3,embedded=reg_info" json:"reg_info"`
}

func (m *Login) Reset()         { *m = Login{} }
func (m *Login) String() string { return proto.CompactTextString(m) }
func (*Login) ProtoMessage()    {}
func (*Login) Descriptor() ([]byte, []int) {
	return fileDescriptor_61c7956abb761639, []int{0}
}
func (m *Login) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Login) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Login.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Login) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Login.Merge(m, src)
}
func (m *Login) XXX_Size() int {
	return m.Size()
}
func (m *Login) XXX_DiscardUnknown() {
	xxx_messageInfo_Login.DiscardUnknown(m)
}

var xxx_messageInfo_Login proto.InternalMessageInfo

// Password используется для изменения пароля пользователя.
type Password struct {
	// домен
	Domain string `protobuf:"bytes,1,opt,name=domain,proto3" json:"domain,omitempty"`
	// уникальный идентификатор пользователя
	UID string `protobuf:"bytes,2,opt,name=uid,proto3" json:"uid,omitempty"`
	// пароль пользователя
	Password string `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
}

func (m *Password) Reset()         { *m = Password{} }
func (m *Password) String() string { return proto.CompactTextString(m) }
func (*Password) ProtoMessage()    {}
func (*Password) Descriptor() ([]byte, []int) {
	return fileDescriptor_61c7956abb761639, []int{1}
}
func (m *Password) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Password) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Password.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Password) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Password.Merge(m, src)
}
func (m *Password) XXX_Size() int {
	return m.Size()
}
func (m *Password) XXX_DiscardUnknown() {
	xxx_messageInfo_Password.DiscardUnknown(m)
}

var xxx_messageInfo_Password proto.InternalMessageInfo

// UserID используется для получения информации о пользователе по его
// логину или уникальному идентификатору.
type UserID struct {
	// домен
	Domain string `protobuf:"bytes,1,opt,name=domain,proto3" json:"domain,omitempty"`
	// Types that are valid to be assigned to User:
	//	*UserID_UID
	//	*UserID_Email
	User isUserID_User `protobuf_oneof:"user"`
}

func (m *UserID) Reset()         { *m = UserID{} }
func (m *UserID) String() string { return proto.CompactTextString(m) }
func (*UserID) ProtoMessage()    {}
func (*UserID) Descriptor() ([]byte, []int) {
	return fileDescriptor_61c7956abb761639, []int{2}
}
func (m *UserID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserID.Merge(m, src)
}
func (m *UserID) XXX_Size() int {
	return m.Size()
}
func (m *UserID) XXX_DiscardUnknown() {
	xxx_messageInfo_UserID.DiscardUnknown(m)
}

var xxx_messageInfo_UserID proto.InternalMessageInfo

type isUserID_User interface {
	isUserID_User()
	MarshalTo([]byte) (int, error)
	Size() int
}

type UserID_UID struct {
	UID string `protobuf:"bytes,2,opt,name=uid,proto3,oneof" json:"uid,omitempty"`
}
type UserID_Email struct {
	Email string `protobuf:"bytes,3,opt,name=email,proto3,oneof" json:"email,omitempty"`
}

func (*UserID_UID) isUserID_User()   {}
func (*UserID_Email) isUserID_User() {}

func (m *UserID) GetUser() isUserID_User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *UserID) GetUID() string {
	if x, ok := m.GetUser().(*UserID_UID); ok {
		return x.UID
	}
	return ""
}

func (m *UserID) GetEmail() string {
	if x, ok := m.GetUser().(*UserID_Email); ok {
		return x.Email
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*UserID) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*UserID_UID)(nil),
		(*UserID_Email)(nil),
	}
}

// BlockID используется для блокировки/разблокировки пользователя.
type BlockID struct {
	// домен
	Domain string `protobuf:"bytes,1,opt,name=domain,proto3" json:"domain,omitempty"`
	// уникальный идентификатор пользователя
	UID string `protobuf:"bytes,2,opt,name=uid,proto3" json:"uid,omitempty"`
	// флаг для блокировки или разблокировки пользователя
	Blocked bool `protobuf:"varint,3,opt,name=blocked,proto3" json:"blocked,omitempty"`
}

func (m *BlockID) Reset()         { *m = BlockID{} }
func (m *BlockID) String() string { return proto.CompactTextString(m) }
func (*BlockID) ProtoMessage()    {}
func (*BlockID) Descriptor() ([]byte, []int) {
	return fileDescriptor_61c7956abb761639, []int{3}
}
func (m *BlockID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockID.Merge(m, src)
}
func (m *BlockID) XXX_Size() int {
	return m.Size()
}
func (m *BlockID) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockID.DiscardUnknown(m)
}

var xxx_messageInfo_BlockID proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Login)(nil), "itube.users.Login")
	golang_proto.RegisterType((*Login)(nil), "itube.users.Login")
	proto.RegisterType((*Password)(nil), "itube.users.Password")
	golang_proto.RegisterType((*Password)(nil), "itube.users.Password")
	proto.RegisterType((*UserID)(nil), "itube.users.UserID")
	golang_proto.RegisterType((*UserID)(nil), "itube.users.UserID")
	proto.RegisterType((*BlockID)(nil), "itube.users.BlockID")
	golang_proto.RegisterType((*BlockID)(nil), "itube.users.BlockID")
}

func init() { proto.RegisterFile("identity.proto", fileDescriptor_61c7956abb761639) }
func init() { golang_proto.RegisterFile("identity.proto", fileDescriptor_61c7956abb761639) }

var fileDescriptor_61c7956abb761639 = []byte{
	// 554 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x53, 0x4d, 0x8b, 0xd3, 0x40,
	0x18, 0xce, 0xf4, 0x23, 0xcd, 0x4e, 0x41, 0x70, 0xfc, 0xa0, 0x54, 0x99, 0x86, 0x5e, 0x2c, 0x42,
	0x13, 0xb7, 0x8b, 0x82, 0xe0, 0xc5, 0x52, 0x75, 0x0b, 0x7b, 0x90, 0x48, 0x61, 0xf1, 0x22, 0xe9,
	0x66, 0x3a, 0x3b, 0xb4, 0xc9, 0xc4, 0xc9, 0xc4, 0xa2, 0xbf, 0x40, 0x6f, 0x7b, 0xf0, 0xe0, 0x0f,
	0xf0, 0x87, 0x78, 0xec, 0xb1, 0x47, 0x4f, 0x5d, 0x37, 0xfd, 0x1f, 0x22, 0xf9, 0xaa, 0x1b, 0xd6,
	0x65, 0x0b, 0xee, 0x29, 0xf3, 0x3e, 0xf3, 0x3c, 0x33, 0x4f, 0x9e, 0x77, 0x5e, 0x78, 0x83, 0x39,
	0xc4, 0x93, 0x4c, 0x7e, 0x34, 0x7c, 0xc1, 0x25, 0x47, 0x75, 0x26, 0xc3, 0x31, 0x31, 0xc2, 0x80,
	0x88, 0xa0, 0x09, 0xe3, 0x4f, 0xba, 0xd1, 0xbc, 0x47, 0x39, 0xa7, 0x33, 0x62, 0x26, 0xd5, 0x38,
	0x9c, 0x98, 0xc4, 0xf5, 0x73, 0x55, 0xb3, 0x4b, 0x99, 0x3c, 0x0e, 0xc7, 0xc6, 0x11, 0x77, 0x4d,
	0xca, 0x29, 0xff, 0xcb, 0x8a, 0xab, 0xa4, 0x48, 0x56, 0x19, 0xfd, 0xc9, 0x39, 0xba, 0x3b, 0x67,
	0x72, 0xca, 0xe7, 0x26, 0xe5, 0xdd, 0x64, 0xb3, 0xfb, 0xc1, 0x9e, 0x31, 0xc7, 0x96, 0x5c, 0x04,
	0xe6, 0x66, 0x99, 0xea, 0xda, 0xdf, 0x01, 0xac, 0x1e, 0x70, 0xca, 0x3c, 0x84, 0xa1, 0xea, 0x70,
	0xd7, 0x66, 0x5e, 0x03, 0xe8, 0xa0, 0xb3, 0xd3, 0x57, 0xa3, 0xd3, 0x56, 0xe9, 0x10, 0x58, 0x19,
	0x8a, 0xee, 0xc3, 0x2a, 0x71, 0x6d, 0x36, 0x6b, 0x94, 0x0a, 0xdb, 0x29, 0x88, 0xda, 0x50, 0xf3,
	0xed, 0x20, 0x98, 0x73, 0xe1, 0x34, 0xca, 0x05, 0xc2, 0x06, 0x47, 0x4f, 0xa1, 0x26, 0x08, 0x7d,
	0xc7, 0xbc, 0x09, 0x6f, 0x40, 0x1d, 0x74, 0xea, 0xbd, 0xdb, 0xc6, 0xb9, 0x6c, 0x0c, 0x8b, 0xd0,
	0xa1, 0x37, 0xe1, 0x7d, 0x6d, 0xb1, 0x6a, 0x29, 0xcb, 0x55, 0x0b, 0x58, 0x35, 0x91, 0x42, 0xed,
	0xaf, 0x00, 0x6a, 0xaf, 0xf3, 0x73, 0xae, 0x72, 0x3a, 0x80, 0xe5, 0x90, 0x39, 0x99, 0xcf, 0x5e,
	0xb4, 0x6a, 0x95, 0x47, 0xc3, 0x41, 0x74, 0xda, 0x7a, 0xf0, 0x50, 0x67, 0x5e, 0x12, 0x80, 0x1e,
	0x7a, 0xec, 0x7d, 0x48, 0xf4, 0xb4, 0x53, 0x13, 0x46, 0x84, 0x3e, 0xe1, 0xc2, 0xb5, 0xe5, 0x21,
	0x38, 0x01, 0x15, 0x2b, 0x96, 0x6f, 0xf3, 0x47, 0xed, 0x6f, 0x00, 0xaa, 0xa3, 0x80, 0x88, 0xe1,
	0xe0, 0x4a, 0x53, 0x2f, 0xff, 0xd3, 0xd4, 0xbe, 0x92, 0xda, 0xc2, 0x79, 0x1b, 0x0a, 0x9e, 0xf6,
	0x95, 0xac, 0x11, 0x7d, 0x15, 0x56, 0xe2, 0x34, 0xdb, 0x5f, 0x00, 0xac, 0xf5, 0x67, 0xfc, 0x68,
	0xba, 0x85, 0xb7, 0xeb, 0x09, 0xac, 0x01, 0x6b, 0xe3, 0xf8, 0x42, 0x92, 0xe6, 0xa5, 0x59, 0x79,
	0xd9, 0xfb, 0x5d, 0x82, 0xda, 0x30, 0x1b, 0x0a, 0xb4, 0x0b, 0x35, 0x8b, 0x50, 0x16, 0x48, 0x22,
	0x10, 0x2a, 0xf4, 0x3f, 0x79, 0x87, 0xcd, 0x9b, 0x05, 0x2c, 0x4e, 0x17, 0xf5, 0xe0, 0xce, 0xf3,
	0x50, 0x1e, 0x73, 0xc1, 0x3e, 0x91, 0x6d, 0x35, 0xcf, 0x60, 0xfd, 0x0d, 0x91, 0x9b, 0x37, 0x73,
	0xa7, 0xc0, 0xc8, 0xe1, 0xe6, 0x5d, 0x23, 0x9d, 0x41, 0x23, 0x9f, 0x2e, 0xe3, 0x45, 0x3c, 0x83,
	0x68, 0x0f, 0xaa, 0x23, 0xdf, 0xb1, 0x25, 0x41, 0x17, 0x8f, 0xbe, 0x54, 0xf4, 0x18, 0x56, 0x93,
	0xc4, 0x51, 0xf1, 0x59, 0x67, 0x5d, 0xb8, 0x54, 0xd6, 0x85, 0xe5, 0x57, 0x44, 0xa2, 0x5b, 0x17,
	0x2e, 0x1a, 0x0e, 0xfe, 0x1d, 0x46, 0xe5, 0x80, 0x05, 0x5b, 0xf3, 0x3b, 0xe0, 0x11, 0xe8, 0xef,
	0x2e, 0xce, 0xb0, 0xb2, 0x3c, 0xc3, 0xca, 0x22, 0xc2, 0x60, 0x19, 0x61, 0xf0, 0x2b, 0xc2, 0xe0,
	0xf3, 0x1a, 0x2b, 0x27, 0x6b, 0xac, 0xfc, 0x58, 0x63, 0xb0, 0x5c, 0x63, 0xe5, 0xe7, 0x1a, 0x2b,
	0x6f, 0x6b, 0xfe, 0x94, 0x9a, 0xb6, 0xcf, 0xc6, 0x6a, 0xe2, 0x72, 0xef, 0x4f, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x7f, 0x5e, 0xf6, 0xcd, 0xce, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// IdentityClient is the client API for Identity service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type IdentityClient interface {
	// Register регистрирует и возвращает информацию о пользователе.
	//
	// Если пользователь уже зарегистрирован, но пароль для него не установлен, то
	// устанавливает новый пароль. Данный случай возникает, если до этого
	// пользователь был зарегистрирован через внешнего провайдера.
	//
	// Возвращает ошибки:
	//  - AlreadyExists - пользователь уже зарегистрирован и у него задан пароль
	//  - NotFound - пользователь заблокирован
	//  - InvalidArgument - неверный формат данных входящего запроса
	//  - Internal - внутренние ошибки
	Register(ctx context.Context, in *Login, opts ...grpc.CallOption) (*User, error)
	// Authorize авторизует пользователя по логину (email) и паролю. Возвращает
	// информацию о пользователе в случае успешной авторизации. В противном случае
	// возвращает ошибку.
	//
	// Возвращает ошибки:
	//  - NotFound - пользователь не зарегистрирован или блокирован
	//  - InvalidArgument - неверный пароль пользователя
	//  - Internal - внутренние ошибки
	Authorize(ctx context.Context, in *Login, opts ...grpc.CallOption) (*User, error)
	// SetPassword заменяет пароль пользователя. Возвращает ошибку, если
	// пользователь не зарегистрирован.
	//
	// Возвращает ошибки:
	//  - NotFound - пользователь не зарегистрирован
	//  - Internal - внутренние ошибки
	SetPassword(ctx context.Context, in *Password, opts ...grpc.CallOption) (*types.Empty, error)
	// Update обновляет информацию о пользователе. Возвращает ошибку,
	// если пользователь не зарегистрирован. Информация, что email проверен, а
	// так же дата обновления игнорируется.
	//
	// Возвращает ошибки:
	//  - AlreadyExists - пользователь с таким email уже зарегистрирован
	//  - NotFound - пользователь не зарегистрирован
	//  - InvalidArgument - неверный формат данных входящего запроса
	//  - Internal - внутренние ошибки
	Update(ctx context.Context, in *User, opts ...grpc.CallOption) (*types.Empty, error)
	// Block используется для блокировки/разблокировки пользователя.
	// Заблокированный пользователь продолжает оставаться зарегистрированных,
	// но не может авторизоваться.
	//
	// Возвращает ошибки:
	//  - NotFound - пользователь не зарегистрирован
	//  - InvalidArgument - неверный формат данных входящего запроса
	//  - Internal - внутренние ошибки
	Block(ctx context.Context, in *BlockID, opts ...grpc.CallOption) (*types.Empty, error)
	// Get возвращает информацию о пользователе по идентификатору или email.
	//
	// Возвращает ошибки:
	//  - NotFound - пользователь не зарегистрирован
	//  - InvalidArgument - неверный формат данных входящего запроса
	//  - Internal - внутренние ошибки
	Get(ctx context.Context, in *UserID, opts ...grpc.CallOption) (*User, error)
	// List возвращает информацию о пользователях по идентификатору или email.
	// Используется для получения информации о других пользователях в потоке.
	List(ctx context.Context, opts ...grpc.CallOption) (Identity_ListClient, error)
}

type identityClient struct {
	cc *grpc.ClientConn
}

func NewIdentityClient(cc *grpc.ClientConn) IdentityClient {
	return &identityClient{cc}
}

func (c *identityClient) Register(ctx context.Context, in *Login, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/itube.users.Identity/Register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identityClient) Authorize(ctx context.Context, in *Login, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/itube.users.Identity/Authorize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identityClient) SetPassword(ctx context.Context, in *Password, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/itube.users.Identity/SetPassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identityClient) Update(ctx context.Context, in *User, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/itube.users.Identity/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identityClient) Block(ctx context.Context, in *BlockID, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/itube.users.Identity/Block", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identityClient) Get(ctx context.Context, in *UserID, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/itube.users.Identity/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identityClient) List(ctx context.Context, opts ...grpc.CallOption) (Identity_ListClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Identity_serviceDesc.Streams[0], "/itube.users.Identity/List", opts...)
	if err != nil {
		return nil, err
	}
	x := &identityListClient{stream}
	return x, nil
}

type Identity_ListClient interface {
	Send(*UserID) error
	Recv() (*User, error)
	grpc.ClientStream
}

type identityListClient struct {
	grpc.ClientStream
}

func (x *identityListClient) Send(m *UserID) error {
	return x.ClientStream.SendMsg(m)
}

func (x *identityListClient) Recv() (*User, error) {
	m := new(User)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// IdentityServer is the server API for Identity service.
type IdentityServer interface {
	// Register регистрирует и возвращает информацию о пользователе.
	//
	// Если пользователь уже зарегистрирован, но пароль для него не установлен, то
	// устанавливает новый пароль. Данный случай возникает, если до этого
	// пользователь был зарегистрирован через внешнего провайдера.
	//
	// Возвращает ошибки:
	//  - AlreadyExists - пользователь уже зарегистрирован и у него задан пароль
	//  - NotFound - пользователь заблокирован
	//  - InvalidArgument - неверный формат данных входящего запроса
	//  - Internal - внутренние ошибки
	Register(context.Context, *Login) (*User, error)
	// Authorize авторизует пользователя по логину (email) и паролю. Возвращает
	// информацию о пользователе в случае успешной авторизации. В противном случае
	// возвращает ошибку.
	//
	// Возвращает ошибки:
	//  - NotFound - пользователь не зарегистрирован или блокирован
	//  - InvalidArgument - неверный пароль пользователя
	//  - Internal - внутренние ошибки
	Authorize(context.Context, *Login) (*User, error)
	// SetPassword заменяет пароль пользователя. Возвращает ошибку, если
	// пользователь не зарегистрирован.
	//
	// Возвращает ошибки:
	//  - NotFound - пользователь не зарегистрирован
	//  - Internal - внутренние ошибки
	SetPassword(context.Context, *Password) (*types.Empty, error)
	// Update обновляет информацию о пользователе. Возвращает ошибку,
	// если пользователь не зарегистрирован. Информация, что email проверен, а
	// так же дата обновления игнорируется.
	//
	// Возвращает ошибки:
	//  - AlreadyExists - пользователь с таким email уже зарегистрирован
	//  - NotFound - пользователь не зарегистрирован
	//  - InvalidArgument - неверный формат данных входящего запроса
	//  - Internal - внутренние ошибки
	Update(context.Context, *User) (*types.Empty, error)
	// Block используется для блокировки/разблокировки пользователя.
	// Заблокированный пользователь продолжает оставаться зарегистрированных,
	// но не может авторизоваться.
	//
	// Возвращает ошибки:
	//  - NotFound - пользователь не зарегистрирован
	//  - InvalidArgument - неверный формат данных входящего запроса
	//  - Internal - внутренние ошибки
	Block(context.Context, *BlockID) (*types.Empty, error)
	// Get возвращает информацию о пользователе по идентификатору или email.
	//
	// Возвращает ошибки:
	//  - NotFound - пользователь не зарегистрирован
	//  - InvalidArgument - неверный формат данных входящего запроса
	//  - Internal - внутренние ошибки
	Get(context.Context, *UserID) (*User, error)
	// List возвращает информацию о пользователях по идентификатору или email.
	// Используется для получения информации о других пользователях в потоке.
	List(Identity_ListServer) error
}

// UnimplementedIdentityServer can be embedded to have forward compatible implementations.
type UnimplementedIdentityServer struct {
}

func (*UnimplementedIdentityServer) Register(ctx context.Context, req *Login) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (*UnimplementedIdentityServer) Authorize(ctx context.Context, req *Login) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Authorize not implemented")
}
func (*UnimplementedIdentityServer) SetPassword(ctx context.Context, req *Password) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPassword not implemented")
}
func (*UnimplementedIdentityServer) Update(ctx context.Context, req *User) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (*UnimplementedIdentityServer) Block(ctx context.Context, req *BlockID) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Block not implemented")
}
func (*UnimplementedIdentityServer) Get(ctx context.Context, req *UserID) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (*UnimplementedIdentityServer) List(srv Identity_ListServer) error {
	return status.Errorf(codes.Unimplemented, "method List not implemented")
}

func RegisterIdentityServer(s *grpc.Server, srv IdentityServer) {
	s.RegisterService(&_Identity_serviceDesc, srv)
}

func _Identity_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Login)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentityServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/itube.users.Identity/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentityServer).Register(ctx, req.(*Login))
	}
	return interceptor(ctx, in, info, handler)
}

func _Identity_Authorize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Login)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentityServer).Authorize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/itube.users.Identity/Authorize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentityServer).Authorize(ctx, req.(*Login))
	}
	return interceptor(ctx, in, info, handler)
}

func _Identity_SetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Password)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentityServer).SetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/itube.users.Identity/SetPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentityServer).SetPassword(ctx, req.(*Password))
	}
	return interceptor(ctx, in, info, handler)
}

func _Identity_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentityServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/itube.users.Identity/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentityServer).Update(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _Identity_Block_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentityServer).Block(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/itube.users.Identity/Block",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentityServer).Block(ctx, req.(*BlockID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Identity_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentityServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/itube.users.Identity/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentityServer).Get(ctx, req.(*UserID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Identity_List_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(IdentityServer).List(&identityListServer{stream})
}

type Identity_ListServer interface {
	Send(*User) error
	Recv() (*UserID, error)
	grpc.ServerStream
}

type identityListServer struct {
	grpc.ServerStream
}

func (x *identityListServer) Send(m *User) error {
	return x.ServerStream.SendMsg(m)
}

func (x *identityListServer) Recv() (*UserID, error) {
	m := new(UserID)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Identity_serviceDesc = grpc.ServiceDesc{
	ServiceName: "itube.users.Identity",
	HandlerType: (*IdentityServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _Identity_Register_Handler,
		},
		{
			MethodName: "Authorize",
			Handler:    _Identity_Authorize_Handler,
		},
		{
			MethodName: "SetPassword",
			Handler:    _Identity_SetPassword_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Identity_Update_Handler,
		},
		{
			MethodName: "Block",
			Handler:    _Identity_Block_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Identity_Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "List",
			Handler:       _Identity_List_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "identity.proto",
}

func (m *Login) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Login) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Login) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RegInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIdentity(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintIdentity(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintIdentity(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintIdentity(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Password) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Password) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Password) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintIdentity(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.UID) > 0 {
		i -= len(m.UID)
		copy(dAtA[i:], m.UID)
		i = encodeVarintIdentity(dAtA, i, uint64(len(m.UID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintIdentity(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.User != nil {
		{
			size := m.User.Size()
			i -= size
			if _, err := m.User.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintIdentity(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserID_UID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserID_UID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.UID)
	copy(dAtA[i:], m.UID)
	i = encodeVarintIdentity(dAtA, i, uint64(len(m.UID)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *UserID_Email) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserID_Email) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Email)
	copy(dAtA[i:], m.Email)
	i = encodeVarintIdentity(dAtA, i, uint64(len(m.Email)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *BlockID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Blocked {
		i--
		if m.Blocked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.UID) > 0 {
		i -= len(m.UID)
		copy(dAtA[i:], m.UID)
		i = encodeVarintIdentity(dAtA, i, uint64(len(m.UID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintIdentity(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintIdentity(dAtA []byte, offset int, v uint64) int {
	offset -= sovIdentity(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Login) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovIdentity(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovIdentity(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovIdentity(uint64(l))
	}
	l = m.RegInfo.Size()
	n += 1 + l + sovIdentity(uint64(l))
	return n
}

func (m *Password) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovIdentity(uint64(l))
	}
	l = len(m.UID)
	if l > 0 {
		n += 1 + l + sovIdentity(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovIdentity(uint64(l))
	}
	return n
}

func (m *UserID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovIdentity(uint64(l))
	}
	if m.User != nil {
		n += m.User.Size()
	}
	return n
}

func (m *UserID_UID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UID)
	n += 1 + l + sovIdentity(uint64(l))
	return n
}
func (m *UserID_Email) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Email)
	n += 1 + l + sovIdentity(uint64(l))
	return n
}
func (m *BlockID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovIdentity(uint64(l))
	}
	l = len(m.UID)
	if l > 0 {
		n += 1 + l + sovIdentity(uint64(l))
	}
	if m.Blocked {
		n += 2
	}
	return n
}

func sovIdentity(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozIdentity(x uint64) (n int) {
	return sovIdentity(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Login) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIdentity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Login: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Login: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIdentity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIdentity
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIdentity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIdentity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIdentity
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIdentity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIdentity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIdentity
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIdentity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIdentity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIdentity
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIdentity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RegInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIdentity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIdentity
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIdentity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Password) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIdentity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Password: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Password: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIdentity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIdentity
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIdentity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIdentity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIdentity
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIdentity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIdentity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIdentity
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIdentity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIdentity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIdentity
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIdentity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIdentity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIdentity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIdentity
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIdentity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIdentity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIdentity
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIdentity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = &UserID_UID{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIdentity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIdentity
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIdentity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = &UserID_Email{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIdentity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIdentity
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIdentity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIdentity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIdentity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIdentity
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIdentity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIdentity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIdentity
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIdentity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIdentity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Blocked = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipIdentity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIdentity
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIdentity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipIdentity(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowIdentity
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIdentity
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIdentity
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthIdentity
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupIdentity
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthIdentity
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthIdentity        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowIdentity          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupIdentity = fmt.Errorf("proto: unexpected end of group")
)
